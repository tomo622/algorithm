## KMP 알고리즘 (Knuth-Morris-Pratt Algorithm)

- 찾으려는 패턴에 대해 **전처리된 pi 배열**을 이용하여 **불일치가 발생한 위치의 이전 부분에서 비교가 필요 없는 구간**을 건너 뛰어 검색 시간과 횟수를 줄이는 방법

- 비교가 불필요한 구간은 **패턴에서 접두사와 접미사가 최대로 일치하는 부분**을 말한다.
  ![kmp_1](https://user-images.githubusercontent.com/19742979/70150595-9ae54b80-16ed-11ea-9fe2-64aea686773c.PNG)
위 그림을 보면 'd'에서 불일치가 발생했다. 이는 <u>'d' 이전까지는 패턴과 동일하다</u>는 뜻이고, 'd' 이전까지의 문자열을 봤을때 맨 앞 'abc'(접두사)와 맨 뒤 'abc'(접미사)가 일치하는 것을 볼 수 있다.
  다음 비교 시에 <u>**텍스트의 해당 접미사**와 **패턴의 해당 접두사**가 일치하는 위치로 바로 이동</u>하여 그 다음 부터 비교한다면 중간에 불필요한 비교를 없앨 수 있다.
**이를 패턴 문자열의 입장에서만 바라본다면 불일치가 발생했을 경우 다음 비교를 위한 패턴의 시작 위치는 해당 위치 이전 문자열에서 일치하는 접두사 'abc' 다음 문자임을 알 수 있다. 즉,  접두사와 접미사가 일치하는 최대 길이(3) 만큼 건너 뛴다. (이때 텍스트의 비교 대상을 순차적으로 진행된다.)**
  ![kmp_3](https://user-images.githubusercontent.com/19742979/70215248-738b8e80-1780-11ea-969d-317eb2f250db.PNG)
  (브루트포스 알고리즘을 이용한 문자열 패턴 매칭은 위 박스 과정을 수행한다.)
  
- pi 배열은 **패턴의 각 문자까지에서 접두사와 접미사가 일치하는 최대 개수**에 대한 정보를 담고 있다. 따라서 패턴 문자열의 길이와 동일한 길이를 갖는다. 이를 통해 **패턴의 다음 비교 대상을 알 수 있다.**
  ![kmp_2](https://user-images.githubusercontent.com/19742979/70152360-69ba4a80-16f0-11ea-86ba-75236e59e071.PNG)
pi 배열이 갖는 값은 다음 세 가지 의미가 있다.
  
  - **불일치 발생 후 다음 비교 시 패턴에서 비교가 불필요한 문자 개수(건너 뛰는 개수)**
  - **불일치 발생 후 다음 비교 시 패턴의 시작 위치, 되돌아갈 위치**
  - **패턴의 i 위치까지의 접미사와 최대로 일치하는 접두사의 마지막 인덱스 + 1**
  - 예) 'e'에서 불일치가 발생할 경우 이전까지 문자열의 접미사와 접두사는 3개 일치한다. 즉 다음 회차 시 **패턴에서 3개를 비교하지 않아도 된다**는 의미와 같고, **비교의 시작 인덱스를 나타내기도 한다.** 즉, 다음 회차시 *인덱스 3*인 'd' 부터 비교를 시작하면 된다. (인덱스 0, 1, 2 번 *3개*를 넘기기 때문에 인덱스 3번 부터 비교한다.)
  
- 시간 복잡도
  O(M+N) 거의 O(M) (M: 문자열의 길이, N: 패턴의 길이)
  
- 과정(pi 배열 생성)
  패턴의 접두사와 접미사를 하나씩 이동하며 비교하다가 일치하지 않는 경우 일치했던 위치까지 되돌아가서 다시 검사하는 방식
  
  ```java
  int j = 0; //j: 접미사의 끝 위치(i)와 비교되는 접두사의 검색 위치
  for(int i = 0; i < pattern.length; i++){ //i: 접미사의 끝 위치, 순차적 이동
      //pi배열을 모두 0으로 초기화
      //...
      
      //접두사의 검색 위치와 접미사의 끝이 일치하지 않는 경우
      //j가 제일 처음으로(index 0) 이동할 때 까지 또는 i 위치의 문자와 일치할 때 까지 이동
      //이동할 때에는 j의 바로 이전 인덱스 위치의 값으로 이동시킨다.
      while(j > 0 && pattern[j] != pattern[i]){
          j = pi[j - 1];
      }
      
      //(위의 반복문을 거쳐 이동된) j 와 i 위치의 값이 일치하는 경우
      //j를 증가시키고 증가된 j 위치를 i 위치의 pi 값으로 넣는다.
      if(pattern[j] == pattern[i]){
          pi[i] = ++j;
      }
  }
  ```
  
- 과정

  ```java
  int j = 0; //j: 패턴 검색 위치
  for(int i = 0; i < text.lenght; i++){ //i: 텍스트의 검색 위치, 순차적 이동
      
      //텍스트와 패턴이 일치하지 않는 경우
      //pi 배열에서 패턴 검색 위치가 되돌아갈 인덱스를 찾는다.
      //찾은 인덱스의 패턴 문자가 텍스트와 일치할 때 까지
      //또는 j가 제일 처음으로(index 0) 이동할 때 까지 반복한다.
      while(j > 0 && pattern[j] != text[i]){
          j = pi[j - 1];
      }
      
      //(위 반복문을 거쳐 이동된) 패턴 검색 위치와 텍스트 검색 위치가 동일한 경우
      if(pattern[j] == text[i]){
          //패턴을 찾은 경우 패턴 검색 위치가 패턴 문자열 배열 끝까지 간다.
          if(j == pattern.length - 1){
              found = true;
              
              //텍스트에 일치하는 패턴이 연달아 중첩되어 있을 수 있기 때문에 
              //패턴 마지막에서 되돌아갈 위치로 바꿔준다.
              //예) 패턴: aaabca, 텍스트: aaabcaabbb
              //[aaabca]abbb에서 패턴을 찾은 경우
              //현재 j 위치 인덱스 5의 pi 값은 1 이다. 이는 인덱스 1로 이동한다.
              //따라서 다음 비교는
              //aaabca[a]bbb
              //     a[a]abca 가 된다.
              j = pi[j];
          }
          //패턴을 아직 찾지 못한 경우
          else{
              j++;
          }
      }
  }
  ```

  